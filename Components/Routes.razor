@using Microsoft.AspNetCore.Components.Routing
@implements IDisposable
@inject NavigationManager Nav
@inject JournalApp.Services.AppState AppState
@inject JournalApp.Services.LockService LockService

<Router AppAssembly="@typeof(App).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(JournalApp.Components.Layout.MainLayout)" />
    </Found>
    <NotFound>
        <p>Page not found.</p>
    </NotFound>
</Router>

@code {
    protected override void OnInitialized()
    {
        Nav.LocationChanged += OnLocationChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            await EnforceLockAsync();
    }

    private async void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        await EnforceLockAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task EnforceLockAsync()
    {
        var path = new Uri(Nav.Uri).AbsolutePath.ToLowerInvariant();

        // Pages that must be accessible BEFORE unlock (otherwise reset flow breaks)
        var isAllowed =
            path.StartsWith("/setup") ||
            path.StartsWith("/unlock") ||
            path.StartsWith("/reset") ||          // allow /reset and any /reset/*
            path.StartsWith("/reset-verify");     // if your page name is specifically this

        if (isAllowed)
            return;

        var hasPin = await LockService.HasPinAsync();

        // No lock configured yet -> force setup
        if (!hasPin)
        {
            Nav.NavigateTo("/setup", true);
            return;
        }

        // Lock exists but user hasn't unlocked session -> force unlock
        if (!AppState.IsUnlocked)
        {
            Nav.NavigateTo("/unlock", true);
        }
    }

    public void Dispose()
    {
        Nav.LocationChanged -= OnLocationChanged;
    }
}
