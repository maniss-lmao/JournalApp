@page "/dashboard"
@using JournalApp.Models
@inject JournalApp.Services.JournalService JournalService
@inject IJSRuntime JS

<h3>Dashboard</h3>

@if (IsLoading) @* Simple loading state while stats are calculated *@
{
    <p>Loading...</p>
}
else
{
    <div style="display:flex; flex-wrap:wrap; gap:14px; margin-bottom:18px">
        @* Summary cards row *@
        <div class="cardbox">
            <div class="cardtitle">Total Entries</div>
            <div class="cardvalue">@TotalEntries</div>
        </div>

        <div class="cardbox">
            <div class="cardtitle">Current Streak</div>
            <div class="cardvalue">@CurrentStreak days</div>
        </div>

        <div class="cardbox">
            <div class="cardtitle">Longest Streak</div>
            <div class="cardvalue">@LongestStreak days</div>
        </div>

        <div class="cardbox">
            <div class="cardtitle">Missed Days (Last 30)</div>
            <div class="cardvalue">@MissedDaysCount</div>
        </div>
    </div>

    <div style="max-width:1000px; display:grid; grid-template-columns: 1fr 1fr; gap:18px;">
        @* Chart layout grid *@
        <div class="cardbox" style="width:auto; padding:16px;">
            <h5>Mood Distribution (Primary Mood)</h5>
            <canvas id="moodPie"></canvas> @* JS draws chart into this canvas *@
        </div>

        <div class="cardbox" style="width:auto; padding:16px;">
            <h5>Most Used Tags</h5>
            <canvas id="tagsBar"></canvas> @* JS draws chart into this canvas *@
        </div>

        <div class="cardbox" style="grid-column: 1 / -1; width:auto; padding:16px;">
            <h5>Word Count Trend (Last 7 Days)</h5>
            <canvas id="wordTrend"></canvas> @* JS draws chart into this canvas *@
        </div>
    </div>

    <div style="max-width:900px; margin-top:18px">
        @* Extra text insights section *@
        <h5>Most Frequent Mood</h5>
        <p>@(string.IsNullOrWhiteSpace(MostFrequentMood) ? "No data yet" : MostFrequentMood)</p>

        <h5>Top Tags (Text)</h5>
        @if (TopTags.Count == 0) @* Only show list when tags exist *@
        {
            <p>No tags yet</p>
        }
        else
        {
            <ul>
                @foreach (var t in TopTags)
                {
                    <li>@t.Tag (@t.Count)</li>
                }
            </ul>
        }

        <h5>Average Words (Last 7 Days)</h5>
        <p>@AvgWordsLast7</p>
    </div>
}

@code {
    private bool IsLoading = true; // Controls loading state

    private int TotalEntries; // Total saved journal entries
    private int CurrentStreak; // Consecutive days up to today
    private int LongestStreak; // Best streak ever achieved
    private int MissedDaysCount; // Missing days in last 30

    private string MostFrequentMood = ""; // Mood that appears most often
    private int AvgWordsLast7; // Average words across last 7 days (days with entries)

    private List<TagCount> TopTags = new(); // Tag ranking for display

    private List<MoodBucket> MoodBuckets = new(); // Pie chart buckets
    private List<WordPoint> WordTrend = new(); // Line chart points

    private bool _chartsRendered = false; // Prevent re-drawing charts repeatedly

    private readonly HashSet<string> PositiveMoods = new(StringComparer.OrdinalIgnoreCase) { "Happy", "Excited", "Relaxed", "Grateful", "Confident" }; // Known positives
    private readonly HashSet<string> NeutralMoods = new(StringComparer.OrdinalIgnoreCase) { "Calm", "Thoughtful", "Curious", "Nostalgic", "Bored", "Okay", "Focused" }; // Known neutrals
    private readonly HashSet<string> NegativeMoods = new(StringComparer.OrdinalIgnoreCase) { "Sad", "Angry", "Stressed", "Lonely", "Anxious" }; // Known negatives

    protected override async Task OnInitializedAsync() // Load data and calculate dashboard metrics
    {
        IsLoading = true;

        var all = await JournalService.GetAllAsync(); // Fetch entries from storage
        TotalEntries = all.Count;

        CalculateStreaks(all); // Current + longest streak
        CalculateMissedDaysLast30(all); // Missed day count
        CalculateMostFrequentMood(all); // Frequent mood
        CalculateTopTags(all); // Most common tags
        await CalculateAvgWordsAndWordTrendLast7(); // Avg words + chart points
        CalculateMoodDistributionBuckets(all); // Positive/neutral/negative buckets

        IsLoading = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) // Draw charts after canvases exist
    {
        if (IsLoading) return;
        if (!_chartsRendered)
        {
            _chartsRendered = true;
            await RenderCharts();
        }
    }

    private async Task RenderCharts() // Sends prepared arrays to JS chart helpers
    {
        var moodLabels = MoodBuckets.Select(x => x.Name).ToArray(); // Pie labels
        var moodValues = MoodBuckets.Select(x => x.Count).ToArray(); // Pie values
        await JS.InvokeVoidAsync("journalCharts.renderMoodPie", "moodPie", moodLabels, moodValues); // Render mood pie

        var tagLabels = TopTags.Select(x => x.Tag).ToArray(); // Bar labels
        var tagValues = TopTags.Select(x => x.Count).ToArray(); // Bar values
        await JS.InvokeVoidAsync("journalCharts.renderTagsBar", "tagsBar", tagLabels, tagValues); // Render tags bar

        var wordLabels = WordTrend.Select(x => x.Label).ToArray(); // Trend labels
        var wordValues = WordTrend.Select(x => x.Words).ToArray(); // Trend values
        await JS.InvokeVoidAsync("journalCharts.renderWordTrend", "wordTrend", wordLabels, wordValues); // Render word trend
    }

    private void CalculateStreaks(List<JournalEntry> all) // Finds current + longest consecutive-day streaks
    {
        if (all.Count == 0)
        {
            CurrentStreak = 0;
            LongestStreak = 0;
            return;
        }

        var dates = all.Select(e => e.EntryDate).Distinct().OrderBy(d => d).ToList(); // Unique ordered dates

        int best = 1;
        int run = 1;

        for (int i = 1; i < dates.Count; i++)
        {
            if (dates[i] == dates[i - 1].AddDays(1)) run++; else run = 1; // Reset when gap exists
            if (run > best) best = run; // Track best run
        }

        LongestStreak = best;

        var today = DateOnly.FromDateTime(DateTime.Today); // Start from today
        int current = 0;

        while (dates.Contains(today.AddDays(-current))) current++; // Count backwards until break
        CurrentStreak = current;
    }

    private void CalculateMissedDaysLast30(List<JournalEntry> all) // Counts empty days over last 30 days window
    {
        var end = DateOnly.FromDateTime(DateTime.Today);
        var start = end.AddDays(-29);

        var dateSet = all.Select(e => e.EntryDate).ToHashSet(); // Fast lookup for entry dates

        int missed = 0;
        for (int i = 0; i < 30; i++)
        {
            var d = start.AddDays(i);
            if (!dateSet.Contains(d)) missed++;
        }

        MissedDaysCount = missed;
    }

    private void CalculateMostFrequentMood(List<JournalEntry> all) // Picks most common primary mood
    {
        MostFrequentMood = all
            .Where(e => !string.IsNullOrWhiteSpace(e.PrimaryMood))
            .GroupBy(e => e.PrimaryMood.Trim())
            .OrderByDescending(g => g.Count())
            .Select(g => g.Key)
            .FirstOrDefault() ?? "";
    }

    private void CalculateTopTags(List<JournalEntry> all) // Builds tag frequency list (top 8)
    {
        var dict = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        foreach (var e in all)
        {
            if (string.IsNullOrWhiteSpace(e.Tags)) continue;

            var tags = e.Tags.Split(',', StringSplitOptions.RemoveEmptyEntries).Select(t => t.Trim()).Where(t => t.Length > 0); // Parse comma tags
            foreach (var tag in tags)
            {
                if (!dict.ContainsKey(tag)) dict[tag] = 0;
                dict[tag]++;
            }
        }

        TopTags = dict
            .OrderByDescending(kv => kv.Value)
            .Take(8)
            .Select(kv => new TagCount { Tag = kv.Key, Count = kv.Value })
            .ToList();
    }

    private async Task CalculateAvgWordsAndWordTrendLast7() // Builds 7-day trend + average words
    {
        var end = DateOnly.FromDateTime(DateTime.Today);
        var start = end.AddDays(-6);

        var range = await JournalService.GetRangeAsync(start, end); // Pull last 7 days only

        if (range.Count == 0)
        {
            AvgWordsLast7 = 0;
            WordTrend = BuildEmptyWeekTrend(start);
            return;
        }

        var map = range.ToDictionary(x => x.EntryDate, x => CountWords(x.Content)); // Date -> word count

        WordTrend = new List<WordPoint>();
        int totalWords = 0;
        int daysWithEntries = 0;

        for (int i = 0; i < 7; i++)
        {
            var d = start.AddDays(i);
            map.TryGetValue(d, out int words);

            WordTrend.Add(new WordPoint { Label = d.ToString("MM-dd"), Words = words }); // Always include day (0 if missing)

            if (words > 0)
            {
                totalWords += words;
                daysWithEntries++;
            }
        }

        AvgWordsLast7 = daysWithEntries == 0 ? 0 : totalWords / daysWithEntries; // Avoid dividing by 0
    }

    private List<WordPoint> BuildEmptyWeekTrend(DateOnly start) // Returns a flat 0-word trend when no data exists
    {
        var list = new List<WordPoint>();
        for (int i = 0; i < 7; i++)
        {
            var d = start.AddDays(i);
            list.Add(new WordPoint { Label = d.ToString("MM-dd"), Words = 0 });
        }
        return list;
    }

    private void CalculateMoodDistributionBuckets(List<JournalEntry> all) // Groups moods into 3 buckets for pie chart
    {
        int pos = 0, neu = 0, neg = 0;

        foreach (var e in all)
        {
            var mood = e.PrimaryMood?.Trim();
            if (string.IsNullOrWhiteSpace(mood)) continue;

            if (PositiveMoods.Contains(mood)) pos++;
            else if (NegativeMoods.Contains(mood)) neg++;
            else neu++; // Anything else treated as neutral
        }

        MoodBuckets = new List<MoodBucket>
        {
            new MoodBucket { Name = "Positive", Count = pos },
            new MoodBucket { Name = "Neutral", Count = neu },
            new MoodBucket { Name = "Negative", Count = neg }
        };
    }

    private int CountWords(string? text) // Rough word count using whitespace splitting
    {
        if (string.IsNullOrWhiteSpace(text)) return 0;

        return text.Split(new char[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }

    private class TagCount
    {
        public string Tag { get; set; } = ""; // Tag name
        public int Count { get; set; } // Tag frequency
    }

    private class MoodBucket
    {
        public string Name { get; set; } = ""; // Bucket label
        public int Count { get; set; } // Bucket size
    }

    private class WordPoint
    {
        public string Label { get; set; } = ""; // X-axis label (date)
        public int Words { get; set; } // Y-axis value (word count)
    }
}
